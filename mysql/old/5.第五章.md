# 索引和执行计划

面试题：

背景: 由于历史遗留问题,导致几十张表是MyISAM.
问题: 业务稍微忙一些的时候,导致业务网站卡住.断电情况下,会有部分数据(索引)损坏.主从1年多没同步了.

分析：

1.确认版本5.5版本

```sh
select version();
```

2.确认业务表的引擎

```
mysql> select table_schema,table_name,engine from information_schema.tables where table_schema not in ('sys','information_schema','mysql','performance_schema') and engine != 'innodb';
```

3.监控锁的情况

```sh
show status like '%lock%';
发现有很多table_lock 信息
```

4.检查主从状态

```sh
show slave status \G;
```

5.询问情况

6.将所有非InnoDB表,替换成InnoDB

```sh
SELECT CONCAT("ALTER TABLE ",table_schema,".",table_name," ENGINE=INNODB;")
FROM information_schema.tables 
WHERE table_schema 
NOT IN ('mysql','information_schema','performance_schema','sys') 
AND ENGINE !='innodb'
INTO OUTFILE '/tmp/alter.sql';
```



information_schema.processlist  表应用案例

```sh
a. 监控业务用户登录的次数
mysql> select user,count(*) from information_schema.processlist where user not in ('root','event_scheduler') gropup by user;
b. 监控sleep的连接个数 
mysql> select  COMMAND,count(*) from information_schema.processlist where  COMMAND='sleep';
c. 监控业务用户的登录总时长 
mysql>  select user,sum(TIME) from information_schema.processlist where user not in ('root','event_scheduler') group  by user;
d. 监控业务用户的登录平均时长 
mysql>  select user,AVG(TIME) from information_schema.processlist where user not in ('root','event_scheduler') group  by user;
```



## 介绍

索引相当于一本书中的目录.起到优化查询(where order by  group by ....)目的

## 类型

Btree  : b-tree,b+tree(b+tree,b*tree),Balance-tree
Rtree
HASH
fulltext

## btree细分

聚簇索引
辅助索引: 单列,联合,前缀..
唯一索引



## 管理命令

### 查看表的索引

```sh
desc world.city;
Key 
----
PRI     ---> 主键索引(聚簇索引)
MUL     ---> 辅助索引
UNI     ---> 唯一索引    
    
mysql> show index from world.city;     #命令
Table      : 表名
Key_name   : 索引名
Column_name: 列名
Cardinality :基数 ,不重复的值的个数(根据统计信息,采样获得的错略值).越大越好.
量化方法: Cardinality/总行数  建议 80% 以上 

```

### 索引创建 

```sh
a. 单列索引
mysql> alter table world.city add index i_p(population);
b. 联合索引 
mysql> alter table world.city add index i_c_p(countrycode,population);
c. 前缀
mysql> alter table world.city add index i_name(name(10));
d. 主键索引
mysql> create table aa (id int);
mysql> alter table aa modify  id int not null primary key auto_increment;

```

### 删除索引

```sh
mysql>  alter table test.t100w dorp index i_k2(k2);
```

### 压测

```sh
mysqlslap --defaults-file=/etc/my.cnf \
--concurrency=100 --iterations=1 --create-schema='test' \
--query="select * from test.t100w where k2='VWlm'" engine=innodb \
--number-of-queries=2000 -uroot -p123 -verbose   #用户及密码
```



## B+tree查找算法介绍

### 平衡 

不管查找哪个数,需要查找次数理论上是相同的.对于一个三层b树来讲,理论上查找每个值都是三次IO

### 擅长范围查找

讲究快速锁定范围. 
B+tree,加入了双向指针(头尾相接),进一步增强范围查找.减少对于ROOT和NON-LEAF的访问次数.

### 构建过程 

```sh
叶子: 先将数据排序,生成叶子节点.
枝  : 保存叶子节点的范围(>=1 <5)+指针(→)
根  : 保存枝节点范围+指针

叶子节点和枝节点都有双向指针.
```



## MySQL 索引如何应用Btree算法

### 名词认识 

page:  数据页,默认16KB 
extent: 区(簇),默认是1MB,连续的64Pages
IOT   : 索引组织表.MySQL在存数据时是按照索引(聚簇索引)组织和存储.

###  MySQL 索引如何应用Btree

**聚簇索引** 

一般都是主键值，或唯一值

**构建过程**

```sh
IOT组织表:
    存储数据时,数据行会按照ID逻辑有序的,在连续的page上进行存储(同一个区内的数据可以保证物理有序)
1.叶子leaf
数据行所在的数据页,构成了叶子节点.
2. non-leaf 内部节点
叶子结点的ID值范围+指针
3. root 
no-leaf ID范围+指针
```



**辅助索引**

查找主键值得索引

**构建过程**

```sh
alter table t1 add index idx(name)

1. 从原表中获取:索引列(name)+ID值
2. 按照索引列值(name)从小到大排序,生成叶子节点中.
3. 枝节点:叶子节点的name范围+指针
4. 根节点:枝节点name的范围+指针
```

**如何起到优化查询的效果**

基于name 列进行条件时.
1. 根据name列的条件值,在辅助索引扫描,获取到ID
2. 拿着ID回表查询,最中获得想要的数据页



**联合索引** 

一个辅助索引无法判断条件

**构建过程**

```sh
叶子节点: 获取ID+name+age ,按照name和age组合排序. 将有序的值存储到连续的数据页中.
枝节点  : 获取叶子节点name列值范围+指针.
根节点  : 获取枝节点 name值的范围+指针.
```

**如何起到优化查询的效果**

```sh
例如:
where name = and age= 

1. 按照name条件值,扫描根节点和枝节点,找到叶子结点.
2. 根据叶子节点内容在做age 条件过滤,最终获得ID
3. 回表查询,根据ID扫描聚簇索引,最终得到数据页.
```

**最左原则**

1. 建立联合索引时,选择基数大的作为最左列.
2. 查询条件中必须包含索引中的最左列



### 如何判断列的基数：

```
mysql> select count(distinct num) from t100w;
+---------------------+
| count(distinct num) |
+---------------------+
|              577046 |
+---------------------+

mysql> select count(distinct k1) from t100w;
+--------------------+
| count(distinct k1) |
+--------------------+
|               1225 |
+--------------------+


```



### 回表的问题 

6.3.1 什么是回表查询?
从辅助索引扫描完之后,再根据ID聚簇索引扫描的过程.

6.3.2 回表会带来什么影响?
a. IO 增多. 
IO 指标?
IOPS?    ---> 每秒IO的次数,定值.
吞吐量?  ---> 300M/s 

b. 随机IO


6.3.2 怎么减少回表?
a. 索引覆盖 
b. 精细化查询条件+合理的联合索引
c. 调整优化器算法.

6.4 索引树高度 

一般3层B+tree,可以存储2000w左右数据.建议4层以内
6.4.1 影响因素
数据行数多
索引长度过长
主键值过长

6.4.2 解决方案
a. 分库分表(分区表,中间件),数据归档(pt-archiver)
b. 数据类型合适简短的,前缀索引
c. 规划简单主键.