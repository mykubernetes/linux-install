# 主从复制

## 介绍

```sh
复制两台以上的节点，通过 binlog 实现最终 “关系同步”。
```

## 传统复制

###  复制过程

```sh
a.先准备两个以上的数据库实例
b.主库打开二进制日志
mysql> select @@log_bin;     #或者配置文件修改
[mysqld]
server_id=51
log_bin=/data/3306/bin-log/mysql-bin
c.不同节点的server_id和server_uuid不同
mysql> select @@server_id;
mysql> select @@server_uuid;
直接修改配置文件后重启
	#主库：
	server_id=51
	#从库
	server_id=52
	[root@db02 ~]# rm -rf /data/3306/data/auto.cnf
d.主库需要创建专用的复制用户
mysql> create user repl@'10.0.0.%' identified with mysql_native_password by  '123';
mysql> grant replication slave on *.* to repl@'10.0.0.%';
e.从库需要先和主库数据同步
	#使用 clone PXB binlog 等操作将数据相同
f.告诉从库复制的起点信息
	#如果用克隆的方法的话，先查出binlog信息
	mysql> select * from performance_schema.clone_status\G
	#如果是mysqldump的方法，就show master status看一下
	#将查到的 binlog 信息填入下面
CHANGE MASTER TO
  MASTER_HOST='10.0.0.51',
  MASTER_USER='repl',
  MASTER_PASSWORD='123',
  MASTER_PORT=3306,
  MASTER_LOG_FILE='mysql-bin.000003',
  MASTER_LOG_POS=196,
  MASTER_CONNECT_RETRY=10;
g.从库开启复制功能
mysql> start slave;
h.从库查看状态
mysql> show slave status\G
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
#有以上两条参数即代表成功
```

### 复制原理

```sh
#涉及到的线程
a.主库线程
	binlog dump thread
	#作用
	a.与从库进行交互
	b.监控binlogde变化
	c.投递binlog给从库
	#监控
	show processlist;
b.从库线程
	IO线程：
	#作用
	a. 连接主库
	b. 和主库的Dump THREAD 线程交互 
	c. 接收和存储主库的binlog日志 ，存储到relaylog（中继日志）中
	d. 表形式：mysql.slave_master_info
	SQL线程
	#作用
	a. 回放relaylog中的日志。	
	b. 表形式：mysql.slave_relay_log_info
	#监控
	show processlist;
    show slave status\G
```

### 主从复制口述

```sh
a.从库先进性change master 操作，记录到master_info 中
b.从库开启start slave 操作，开启 IO 和 SQL 线程
c.IO线程根据master_info信息链接主库
d.主库会分配给他一个专用的DUMP线程和IO线程互相通信
e.IO线程会根据master_info中position和binlog信息请求主库最新的binlog信息
f.DUMP线程会截取主库binlog中最新线程发送给从库
g.从库接受binlog信息，存储至Relay_Log_File 中，并把最新信息更新至master_info中
h.SQL线程会先读取Relay_info，获取上一次的回放位置点，回放最新的relay_log
i.回放完之后会更新至Relay_info中
注：主库的dump线程实时监控主库的binlog变化
   从库relaylog,会自动被清理
```

### 监控主从复制

```sh
主库 : 
	mysql> show master status ;
	mysql> show processlist;
    mysql> show slave hosts;   #从库需开启report_host,report_port
	vim /etc/my.cnf
	report_host=10.0.0.52
	report_port=3306
	
从库 ：
	mysql> show slave status\G
	
#主库相关信息：
mysql> select * from mysql.slave_master_info\G;
#从库SQL线程回放信息
mysql> select * from mysql.slave_relay_log_info\G
Relay_log_name: ./db02-relay-bin.000009
Relay_log_pos: 411
Master_log_name: mysql-bin.000004      #复制到主库的哪了
Master_log_pos: 196					   #制到主库的position号

#面试题: 如何计算,主从日志差异的日志量(字节)?
主库的show master status - 从库的show slave status\G
#监控线程状态
mysql> show slave status\G
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Last_IO_Errno: 0
Last_IO_Error: 
Last_SQL_Errno: 0
Last_SQL_Error: 
#过滤复制相关监控
Replicate_Do_DB: 
Replicate_Ignore_DB: 
Replicate_Do_Table: 
Replicate_Ignore_Table: 
Replicate_Wild_Do_Table: 
Replicate_Wild_Ignore_Table:
#主从延时的时间.
Seconds_Behind_Master: 0
#延时从库状态
SQL_Delay: 0
SQL_Remaining_Delay: NULL
# gtid 复制相关信息
Retrieved_Gtid_Set: 
Executed_Gtid_Set: 00bf718b-491c-11eb-81a2-000c2905f029:1-4
```

### 主从复制故障分析及处理

**IO线程故障**

```sh
#故障分类
a. IO 
干的活: 连接主库,请求 接收 存储日志
#Connecting  : 连接故障
		1. 外部因素
			网络: 网络不通,防火墙等.
		2. 内部因素
			数据库异常
			用户 密码  IP  PORT 加密插件
			server_id server_uuid 
			连接数上限
	 	连接故障重现：
	 		1. 宕掉主库
	 		2. 用户 密码  IP  PORT 加密插件
	 		3. 最大连接数上限
通用的排查方法: 
	使用复制相关信息,mysql 命令进行手工连接测试.
#no  ：
	1. Server_id 或者Server_uuid重复
	2. binlog 位置点写错了.
	3. 日志损坏 
	reset master ...

#重置主库方法
stop slave;
reset slave all;
change master to
start slave;

```

**SQL线程故障**

```sh
b.sql
主要工作:回放relay log 中的 SQL语句 
#no  :
	1. 需要创建的对象已经存在
	2. 删除和修改的对象不存在
	3. 约束冲突
	从库被误写入了.
	双主设计问题
	高可用脑裂
	主从数据不一致.
#故障重现：
	1. 从库误写入，创建一个数据库
	2. 主库接着创建
	3. 主从复制故障...
#处理方法：
以主库为主：
	只需从库删除创建的库即可
	mysql> set sql_log_bin=0;
	mysql> drop database ...
	mysql> set sql_log_bin=1;
以从库为主：
	没开GTID的模式: 
	mysql> stop slave;
	mysql> set global sql_slave_skip_counter=1;
	mysql> start slave;
	开了GTID的模式：
	mysql> stop slave;
	mysql> show slave status\G   
	#去找 Retrieved_Gtid_Set 看他执行到哪个gtid了
	mysql> set gtid_next='00bf718b-491c-11eb-81a2-000c2905f029:6';
	mysql> begin;commit;
	mysql> set gtid_next='AUTOMATIC';
	mysql> start slave;
从库被写入,源头解决问题:
	设置从库为只读库.
	mysql> set global  read_only=1;
	mysql> set global  super_read_only=1;
```



## 主从延时

### 什么是主从延时? 

```sh
主库做了操作,从库好久没跟上.
```

### 怎么监控

```sh
#可以通过日志的时间戳间隔：
db01 [(none)]>show slave status\G
Seconds_Behind_Master: 0

#可以通过日志量来判断
非GTID：
主库：show master status\G    #查看position号
从库：show slave status\G     #查看Exec_Master_Log_Pos
判断上面两者的相差量即可

GTID：
通过GTID 来判断
```

### 原因

```sh
#外部原因
	网络慢 . 
	主从硬件配置差异大.
	参数.
	版本(只支持从低到高.不支持从高到低). 
#内部原因
主库：
	dump线程是串行工作的，如果主库并发事务量高,或者大事务时.传输时就会有较高延时.
	解决方案：
	mysql已经为我们很好地解决了问题，5.6+版本,加入了Group Commit(GC)技术.两个指标时间延时+个	  数控制进行组提交.但是依然怕大事务.
	binlog_group_commit_sync_delay=1
	binlog_group_commit_sync_no_delay_count=1000

从库：
	SQL线程是串行工作的，主库的并发事务量大或者大事务.都会导致 SQL线程回放慢.
	解决方案：
	5.6版本加入了SQL线程并发回放机制. 以database级别进行并发回放.意思是只要是不同库的操作，就不	  会产生顺序问题，可以并发回放。
	5.7版本，加入了Logical_clock模式,使得在主库能够group commit的事务(last_committed=8),	  并且根据sequence_number=9在从库并发回放。意思就是在GC阶段给事务编号，按照编号进行并发的回放
	#查询方法
	db01 [(none)]>select @@slave_parallel_type;
		slave_parallel_type:
		该参数从msyql5.7.2引入的，有两个值，一个是database，另一个是logical_clock,mysql5.7		 之后引入了基于组提交的并行复制，通过设置参数 slave_parallel_workers>0 并且			         slave_parallel_type='LOGICAL_CLOCK'实现
	db01 [(none)]>select @@slave_parallel_workers;
		slave_parallel_workers:
		设置多个进程来并发的执行relay log中主库提交的事务，最大值为1024
	8.0版本， writesets 写集合方式. MGR.
#综上所述：
	1. 历史遗留的延时问题,在版本升级过程中基本解决了.
	2. 所以主从延时,我们面临的问题就是优化业务. 所以减少大事务,锁问题,性能较差SQL才是优化主从延时	   的重点.
```



## 数据的最终一致性---（增强）半同步

### 半同步复制-after_commit 和 after_sync

```sh
5.5开始支持半同步复制,但是没有GC机制,性能极差,机会没人用
5.6 版本时 ,加入了GC机制,半同步复制开始被接收.使用的是after_commit机制,但是是在redo commit之后进行等待ACK确认.
这里会有一个痛点,如果主库redo commit阶段宕机宕机了,从库又获取到了binlog,会出现从库比主库数据"多"的问题.导致数据不一致.
5.7版本+以后,加入了after_sync机制,在binlog commit(binlog sync disk)阶段,等待从库ACK,不管谁宕机,都能保证最终一致性.
#另外
不管哪种方式,还会出现,如果ACK超时,会被切换为异步复制的模式.还是有数据不一致的风险.
如果公司能容忍,可以使用这种架构,建议使用增强半同步+GTID模式.
如果不能容忍,可以使用MGR  PXC .

```

### 增强半同步复制配置

```sh
#1.先加载插件
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';   #主
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';     #从
#2.查看插件是否加载成功
db01 [(none)]>show plugins;     #最下面两行
#3.启动增强半同步复制
SET GLOBAL rpl_semi_sync_master_enabled = 1;			#主
SET GLOBAL rpl_semi_sync_slave_enabled = 1;				#从
#4.重启从库的IO线程
STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;
#5.查看是否正在运行，都为on即可
show status like 'Rpl_semi_sync_master_status';			#主
show status like 'Rpl_semi_sync_slave_status';			#从
#6.其他的优化参数
show variables like '%semi%';     #主库查询
-----------------------------------
rpl_semi_sync_master_enabled                =ON
rpl_semi_sync_master_timeout                =1000
rpl_semi_sync_master_trace_level            =32
rpl_semi_sync_master_wait_for_slave_count   =1
rpl_semi_sync_master_wait_no_slave          =ON
rpl_semi_sync_master_wait_point             =AFTER_SYNC    #5.7以后默认
rpl_semi_sync_slave_enabled                 =ON
rpl_semi_sync_slave_trace_level             =32
--------------------------------------
#主库开启GC模式
mysql> set global binlog_group_commit_sync_delay              =1;
mysql> set global binlog_group_commit_sync_no_delay_count     =1000;
```

## 过滤复制

### **什么是过滤复制**

```sh
选择性复制
```

### **应用场景**

```sh
业务的分离.
部分数据同步.
```

### **如何实现**

```sh
#主库： 用是否来记录binlog日志来控制
show master status;  
binlog_do_db :白名单      binlog_ignore_db ：黑名单
#从库： 用SQL线程是否回放来决定
show slave status\G;
针对库的黑白名单：
replicate_do_db=world
replicate_ignore_db=test
针对表的黑白名单：
replicate_do_table=world.city
replicate_ignore_table:test.t100w
针对模糊匹配：
replicate_wild_do_table=oldboy.t*
replicate_wild_ignore_table=oldguo.t*
```

### **配置演练**

```sh
#1.先停掉sql线程
mysql> stop slave sql_thread;
#2.配置黑白名单
mysql> change replication filter replicate_do_db = (wdnmd, test);
#3.开启sql线程
mysql> start slave sql_thread;
注：在配置文件里写的话不能同时写多个库，只能一个一个写
```



## 延时从库

### 什么是延从库

```sh
是我们认为配置的一种特殊从库.人为配置从库和主库延时N小时.
```

### 为什么要有延时从库

```sh
什么是数据库损坏？
物理损坏
主从复制非常擅长解决物理损坏.

逻辑损坏
普通主从复制没办法解决逻辑损坏   主要为了解决物理损坏
```

### 配置延时库

```sh
SQL线程延时:数据已经写入relaylog中了,SQL线程"慢点"运行
一般企业建议3-6小时,具体看公司运维人员对于故障的反应时间。

stop slave;
CHANGE MASTER TO MASTER_DELAY = 300;    #设置延时时间为300s
start slave;
```

### 延时库应用

```sh
#故障恢复思路
1.发现故障
2.停掉从库线程
3.设置超时时间为0s
4.设置SQL回放的位置点，并开启从库线程
5.找回数据，恢复业务
#故障模拟演练
1.主库先模拟创建个库，插入点数据

2.从库开启延时
stop slave;
CHANGE MASTER TO MASTER_DELAY = 300;    #设置延时时间为300s
start slave;

3.主库删除创建的库
drop database ...

4.从库先停掉SQL线程，阻止其继续回放
stop slave sql_thread;

5.将延时时间设置为0
CHANGE MASTER TO MASTER_DELAY = 0;

6.找到删除库的操作的position号
show relaylog events in 'db02-relay-bin.000002'   #可使用 show slave status\G查看

7.将其手动回放到删库之前的操作
START SLAVE SQL_THREAD UNTIL  RELAY_LOG_FILE = 'db01-relay-bin.000002',
RELAY_LOG_POS = 1634  ;    #这里的position号是起点，终点为下一行的起点position号

8.如果开启GTID，可以按照GTID方式UNTIL
START SLAVE UNTIL SQL_BEFORE_GTIDS = "38e9a30b-4a73-11eb-9ef6-000c296ddbb3:15";
#GTID 去show relaylog events in 'db02-relay-bin.000002'里面去找
# 类似SET @@SESSION.GTID_NEXT= '38e9a30b-4a73-11eb-9ef6-000c296ddbb3:15' |
# 一般在操作的下面为GTID的终点
```



## GTID复制

### 介绍

```sh
GTID(Global Transaction ID)是对于一个已提交事务的唯一编号，并且是一个全局(主从复制)唯一的编号。
它的官方定义如下：
GTID =server_uuid : transaction_id
7E11FA47-31CA-19E1-9E56-C43AA21293967:29

什么是sever_uuid，和Server-id 区别？
核心特性: 全局唯一,具备幂等性
```

### GTID核心参数

```sh
重要参数：
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1

gtid-mode=on                        --启用gtid类型，否则就是普通的复制架构
enforce-gtid-consistency=true       --强制GTID的一致性
log-slave-updates=1                 --slave更新是否记入日志

```

### 配置过程

```sh
5.4.1 清理环境
pkill mysqld
 \rm -rf /data/3306/data/*
 \rm -rf /data/3306/binlog/*
 \mv /etc/my.cnf /tmp
 mkdir -p /data/3306/data /data/3306/binlog/
 chown -R mysql.mysql /data/*
 
 
5.4.2 准备配置文件
主库db01：
cat > /etc/my.cnf <<EOF
[mysqld]
basedir=/usr/local/mysql/
datadir=/data/3306/data
socket=/tmp/mysql.sock
server_id=51
port=3306
secure-file-priv=/tmp
log_bin=/data/3306/binlog/mysql-bin
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
[mysql]
prompt=db01 [\\d]>
EOF

slave1(db02)：
cat > /etc/my.cnf <<EOF
[mysqld]
basedir=/usr/local/mysql
datadir=/data/3306/data
socket=/tmp/mysql.sock
server_id=52
port=3306
secure-file-priv=/tmp
log_bin=/data/3306/binlog/mysql-bin
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
[mysql]
prompt=db02 [\\d]>
EOF

slave2(db03)：
cat > /etc/my.cnf <<EOF
[mysqld]
basedir=/usr/local/mysql
datadir=/data/3306/data
socket=/tmp/mysql.sock
server_id=53
port=3306
secure-file-priv=/tmp
log_bin=/data/3306/binlog/mysql-bin
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1
[mysql]
prompt=db03 [\\d]>
EOF



5.4.3 初始化数据
mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql  --datadir=/data/3306/data 

5.4.4 启动数据库
/etc/init.d/mysqld start


5.4.5 构建主从：
master:51
slave:52,53

# 51:
create user repl@'10.0.0.%' identified with mysql_native_password by '123';
grant replication slave  on *.* to repl@'10.0.0.%' ;

# 52\53:

change master to 
master_host='10.0.0.51',
master_user='repl',
master_password='123' ,
MASTER_AUTO_POSITION=1;
start slave;


注意： 
如果是已经运行很久的数据库，需要构建从库，都是需要备份恢复主库数据后再开启主从的。
mysqldump来讲，不要加--set-gtid-purged=OFF功能。
```



## 多源复制

```sh
## 6.1 架构

## 6.2 主机角色

| 主机角色 | 地址      | 端口 |
| -------- | --------- | ---- |
| Master1  | 10.0.0.51 | 3306 |
| Master2  | 10.0.0.52 | 3306 |
| Slave    | 10.0.0.53 | 3306 |

## 6.3 配置过程

### a. GTID环境准备

​```
(1) 清理环境
pkill mysqld 
rm -rf /data/3306/*
\mv /etc/my.cnf /tmp 

(2) 创建需要的目录 
mkdir -p /data/3306/data /data/3306/binlog
chown -R mysql.mysql /data

(3) 准备配置文件 
# db01 
cat > /etc/my.cnf <<EOF
[mysqld]
user=mysql
basedir=/usr/local/mysql
datadir=/data/3306/data
server_id=6
socket=/tmp/mysql.sock
log_bin=/data/3306/binlog/mysql-bin
gtid_mode=ON
enforce_gtid_consistency
log-slave-updates=1
secure-file-priv=/tmp
innodb_flush_method=O_DIRECT
slow_query_log=ON
slow_query_log_file=/data/3306/data/db01-slow.log
long_query_time=0.1
log_queries_not_using_indexes
master_info_repository=TABLE
relay_log_info_repository=TABLE
[client]
socket=/tmp/mysql.sock
[mysql]
prompt=db01 [\\d]>
socket=/tmp/mysql.sock
EOF

# db02 
cat > /etc/my.cnf <<EOF
[mysqld]
user=mysql
basedir=/usr/local/mysql
datadir=/data/3306/data
server_id=7
socket=/tmp/mysql.sock
log_bin=/data/3306/binlog/mysql-bin
gtid_mode=ON
enforce_gtid_consistency
log-slave-updates=1
secure-file-priv=/tmp
innodb_flush_method=O_DIRECT
slow_query_log=ON
slow_query_log_file=/data/3306/data/db01-slow.log
long_query_time=0.1
log_queries_not_using_indexes
master_info_repository=TABLE
relay_log_info_repository=TABLE
[client]
socket=/tmp/mysql.sock
[mysql]
prompt=db02 [\\d]>
socket=/tmp/mysql.sock
EOF

# db03 
cat > /etc/my.cnf <<EOF
[mysqld]
user=mysql
basedir=/usr/local/mysql
datadir=/data/3306/data
server_id=8
socket=/tmp/mysql.sock
log_bin=/data/3306/binlog/mysql-bin
gtid_mode=ON
enforce_gtid_consistency
log-slave-updates=1
secure-file-priv=/tmp
innodb_flush_method=O_DIRECT
slow_query_log=ON
slow_query_log_file=/data/3306/data/db01-slow.log
long_query_time=0.1
log_queries_not_using_indexes
master_info_repository=TABLE
relay_log_info_repository=TABLE
[client]
socket=/tmp/mysql.sock
[mysql]
prompt=db03 [\\d]>
socket=/tmp/mysql.sock
EOF

(4) 初始化数据 
mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql  --datadir=/data/3306/data 

(5) 启动数据库
/etc/init.d/mysqld start 

(6) 构建主从  
# 1. 创建复制用户(主节点)
set sql_log_bin=0;
create user repl@'10.0.0.%' identified with mysql_native_password by '123';
grant replication slave on *.*  to repl@'10.0.0.%' ;
set sql_log_bin=1;

### b. 配置多源复制

CHANGE MASTER TO MASTER_HOST='10.0.0.51',MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_AUTO_POSITION=1 FOR CHANNEL 'Master_1';                

CHANGE MASTER TO MASTER_HOST='10.0.0.52',MASTER_USER='repl', MASTER_PASSWORD='123', MASTER_AUTO_POSITION=1 FOR CHANNEL 'Master_2';           

start slave for CHANNEL  'Master_1';
start slave for CHANNEL  'Master_2';
​```

### c. 多源复制监控
db03 [(none)]>SHOW SLAVE STATUS FOR CHANNEL 'Master_1'\G
db03 [(none)]>SHOW SLAVE STATUS FOR CHANNEL 'Master_2'\G


select * from performance_schema.replication_connection_configuration\G
SELECT * FROM performance_schema.replication_connection_status WHERE CHANNEL_NAME='master_1'\G
select * from performance_schema.replication_applier_status_by_worker;


### d.多源复制配置过滤
mysql> CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db1.%') FOR CHANNEL "master_1";
mysql> CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db2.%') FOR CHANNEL "master_2";

```



## 作业

```sh
#使用mysqldump 或者 xtrabackup  做主从 db03

#1.使用mysqldump 方式
#主机：51 、53
a.和上面一样，准备server_id server_uuid ,开启binlog日志，删除auto.cnf文件，重新启动数据库
b.同时进行 reset master;  操作，将日志清空。
c.主库用 mysqldump 的方式进行数据的全备，之后再创建个库，插入点数据操作。
d.查看起点和终点position号，起点：全备里面  终点：show binlog events in '..'
f.使用 mysqlbinlog 对日志进行截取，追加到文件里面
g.将 全备文件 和 binlog增备文件 发送到从主机。 
h.从主机进行数据的导入
i.告诉从库起点信息，可在主库 show master status 查看
j.开启复制功能  start slave
k.检查状态  show slave status 
```

