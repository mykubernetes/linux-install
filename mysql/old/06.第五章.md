## 执行计划

### 介绍

explain: 
SQL在执行时,优化器优化后,选择的cost最低的执行方案.

### 获取

```sh
mysql> desc select * from t100w where k1='Vs' and k2='mnij' and num<27779;
+----+-------------+-------+------------+-------+---------------+------+---------+------+-
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | 
+----+-------------+-------+------------+-------+---------------+------+---------+------+-
|  1 | SIMPLE      | t100w | NULL       | range | idx           | idx  | 31      | NULL | 
+----+-------------+-------+------------+-------+---------------+------+---------+------+
```

### 看

```sh
table : sql语句操作的表.多表时有意义.

type  : 查找类型,全表\索引

possible_keys : 可能会用的索引 

key   : 最终选择的索引 

key_len : 索引覆盖长度.联合索引有意义

rows   : 估算值,要扫描的行数

Extra  : 额外信息
```

### type输出信息

```sh
ALL：全盘扫描（*，not in ，！=）
mysql> desc select * from t100w;

index：全索引扫描
mysql> desc select id,population from world.city;

range：范围扫描 (> ,< ,>=,<=,like ,in ,or)   前提改列有索引
mysql> desc select * from t100w where id<10;
mysql> desc select * from world.city where countrycode like 'CH%';
mysql> desc select * from world.city where countrycode in ('CHN','USA');

ref：辅助等值索引
mysql> desc select * from t100w where id=1;

eq_ref：多表连接时,非驱动表的连接条件是主键或唯一键
select * from a join b  on a.id=b.aid

const（system）：主键或唯一键等值查询
```

### key_len

a. 介绍
索引覆盖长度(联合索引)

idx(a,b,c)   长度 = a+b+c

算法：

```sh
字符集: 
	utf8 ,字符串列(char(10)) , N*3
    utf8mb4,N*4 
非空  :
	NN : 忽略
	没有NN: +1

数据类型: 
	tinyint  1 
	int      4
	
	char(10)  
	varchar(10)   +2
	
	timestamp  4
	datetime   8
	
例：
desc t100w;
+-------+-----------+------+-----+-------------------+-----------------------------------------------+
| Field | Type      | Null | Key | Default           | Extra                                         |
+-------+-----------+------+-----+-------------------+-----------------------------------------------+
| id    | int       | YES  | MUL | NULL              |                                               |
| num   | int       | YES  |     | NULL              |                                               |
| k1    | char(2)   | YES  | MUL | NULL              |                                               |
| k2    | char(4)   | YES  |     | NULL              |                                               |
| dt    | timestamp | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+-------+-----------+------+-----+-------------------+-----------------------------------------------+
num列的索引长度：5
k1列的索引长度：9
k2列的索引长度:17
```



### 联合索引应用细节

idx(a,b,c)

1  完全覆盖

```sh
...where a= and b= and c= 
...where  b= and c=  and   a=
...where a= and b= and c>    #有判断的，其索引一定在最后
...where a= and b= order  c=
desc select * from student where stuname='aa' and stuage  in (10,20)  and gender='M';
```

2  部分覆盖

```sh
# 前提：stuage 列索引为第二个或第一个
desc select * from student where stuage>10 and stuname='aa'  and gender='M';
desc select * from student where stuname='aa' and stuage>10 and gender='M';   #上面这俩一样
...where a= and b=
...where a= 
...where a= and c=
```

3  不覆盖

```sh
b= and c=       #没有第一列
b= 
c=
```

4  最左原则

```sh
1. 选择基数大的列作为最左列
2. 查询条件中必须包含最左列条件
```



###  extra

```sh
filesort   : 查询中出现了额外的排序.
order by group by 
Using index condition   : 存储引擎层根据索引尽可能的过滤数据,然后在返回给服务器层根据where其他条件进行过滤
```



## 扩展

### 8.0的新特性

1  不可见索引

不删除索引，同时不让优化器选择该索引

```sh
mysql> alter table t100w alter index idx_1 invisible;   #设置该索引为不可见索引
mysql> alter table t100w alter index idx_1 visible;   #改回来
```

2  倒叙索引

```sh
...where a order by b ,c desc  
idx(a,b,c desc)
```

### 索引自优化

1  AHI  

自适应的HASH索引

```sh
a. 自适应,根据缓冲区中索引页的热度,自动生成HASH索引表
b. 快速锁定热点索引页在内存的地址.
```



2  Change buffer (以前叫insert buffer)

```sh
存储辅助索引的变更.
将来需要自动在内存中进行merge.
```



3  优化器算法

  a. 查询优化器算法

```sh
mysql>  select @@optimizer_switch;

index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=off,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on,hash_join=on 
```

  b.  设置优化器算法

```sh
mysql> set global optimizer_switch='index_merge_intersection=off';
# 对多个索引分别进行条件扫描，然后将它们各自的结果进行合并
也可以同样适用在配置文件中
```

实例：Index Condition Pushdown  下推索引

```sh
select * from orders where customer_id<4 and value=290;
在没有ICP之前它是这样执行的：
1. 从索引里面取出customer_id<4的记录，然后利用主键字段读取整个行
2. 然后对这个完整的行利用value=290这个进行判断看是否符合条件。

有了ICP之后则是这样执行的：
1. 从索引里面取出customer_id<4的记录，然后利用这个索引的其他字段条件进行判断，如果条件成立，执行第2步，否则第3步
2. 在上一步中筛选出来符合条件的才会去主键索引里面找到这个完整行。



打开方法：
mysql> set global optimizer_switch='index_condition_pushdown=on';    #默认打开
使用标志：  extra 选项是 Using index condition

1.如果不使用 该参数，并且没有合适的索引，需要时间：
mysql> set global optimizer_switch='index_condition_pushdown=off';
mysql>  select * from t100w where k1='Vs'  and num<27779 and k2='mnij';
   #总共耗费 0.35s
2.打开该参数，同样没有索引，需要时间：
mysql> set global optimizer_switch='index_condition_pushdown=on';
mysql>  select * from t100w where k1='Vs'  and num<27779 and k2='mnij';
   #总共耗费0.3s
3.不使用该参数，建立合适的索引，需要时间：
mysql> alter table t100w add index idx(k1,k2,num);
mysql>  select * from t100w where k1='Vs'  and num<27779 and k2='mnij';
   #总共耗时0.04s
```



 4  MRR  (multi range read)

https://dev.mysql.com/doc/refman/8.0/en/mrr-optimization.html

辅助索引条件查询时,先扫描辅助索引,获得ID值,放在read_rnd_buffer中,由MRR进行排序后,回表查询.

```sh
mysql>  select @@optimizer_switch;     #可查询mrr状态
#是开好还是关着好具体看实际压测情况
```



## 索引应用规范

### 建立索引的原则（DBA运维规范）

```sh
(1) 必须要有主键,业务无关列。
(2) 经常做为where条件列  order by  group by  join on, distinct 的条件(业务:产品功能+用户行为)
(3) 最好使用唯一值多的列作为索引列,如果索引列重复值较多,可以考虑使用联合索引
(4) 列值长度较长的索引列,我们建议使用前缀索引.
mysql> select count(distinct left(name,19)) from city;
(5) 降低索引条目,一方面不要创建没用索引,不常使用的索引清理,percona toolkit(xxxxx)

a. 查看哪些表没有用过：
select * from sys.schema_unused_indexes 
where object_schema not in ('sys','mysql','information_schema','performance_schema');
b. 查看哪些索引是重复的，并给出建议：
select *  from sys.schema_redundant_indexes 
where table_schema not in ('sys','mysql','information_schema','performance_schema')\G

(6) 索引维护要避开业务繁忙期，建议用pt-osc。 
(7) 联合索引最左原则
```

### 不走索引的情况

1  没有查询条件，或者查询条件没有建立索引
select * from t1  ;
select * from t1 where  1=1;

2  查询结果集是原表中的大部分数据，应该是15-25%以上。
查询的结果集，超过了总数行数25%，优化器觉得就没有必要走索引了。
MySQL的预读功能有关。

3  索引本身失效，统计信息不真实

```sh
索引有自我维护的能力。
对于表内容变化比较频繁的情况下，有可能会出现索引失效。
一般是删除重建

现象:
有一条select语句平常查询时很快,突然有一天很慢,会是什么原因
select?  --->索引失效,统计数据不真实

innodb_index_stats  
innodb_table_stats  

mysql> ANALYZE TABLE world.city;   #查看表的状况
```

4  查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等)

```sh
错误的例子：select * from test where id-1=9;
正确的例子：select * from test where id=10;
算术运算
函数运算
子查询
```

5  隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误.

```sh
mysql> desc select * from b where telnum=110;
mysql> desc select * from b where telnum='110';
```

6  < > ，not in 不走索引（辅助索引）   ******

7  like "%_" 百分号在最前面不走
