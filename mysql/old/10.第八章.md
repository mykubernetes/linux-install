# 备份恢复

## 作用

```sh
处理数据损坏.
数据损坏: 
	物理损坏  : 磁盘,核心数据文件被删除或损坏. 
	逻辑损坏  : drop , delete ,truncate ,update

数据损坏方法:
	物理: 主从复制  ,  高可用 
    逻辑: 备份,binlog,binlog2sql,延时从库
```

## 职责

```sh
a. 设计能备份和恢复的策略
b. 备份要定期检查
c. 定期的恢复演练
d. 数据损坏的恢复(效率,一致性)
f. 迁移,升级,主从.
```



## 备份的工具

### 逻辑备份

```sh
mysqldump (MDP)
mysqlbinlog 
mydumper 
```

### 物理备份

```sh
Percona Xtrabackup (PXB,XBK,Xbackup)
MySQL Enterprise Backup (MEB)
```

### 8.0 克隆(8017+版本)

```sh
Clone Plugin
```



## mysqldump(MDP)应用 

### **介绍**

mysqldump 是一款逻辑备份工具

备份的结果: SQL语句,Create database, create table , insert into 语句 

### 逻辑备份

```sh
	RR 级别 
	获取一致性快照
```

**元数据备份**

```sh
#所谓元数据，就是表结构什么的
	FTWRL ----> 
	Flush tables with read lock;    ---> MDL     #一种锁
	
	Flush tables ---> close tables,阻止所有commit  #备份时不让你进行commit操作
	read lock    ---> all  read lock 			 #加锁，不让你进行插入操作

	show create database ..  --->  建库语句
	show create  table   ..  --->  建表语句
    unlock tables;               #最后进行解锁
```

**数据行备份**

```sh
	select  --->  
	InnoDB 可以进行快照备份
	拼接成insert 
	非InnoDB表,锁表备份的.
#通俗来讲就是将读到的内容进行拼接
```

### 适合的场景

```sh
单节点数据量,100G以内,单表2000w以内.可以使用MDP
恢复时间一般是备份时间的3-5倍.
```

### 参数

```sh
#连接参数：
-u     #指定用户
-p 	   #指定密码
-h 	   #指定主机
-P 	   #指定端口
-S 	   #指定sock套接字文件


#备份参数：
-A    #备份全部数据
[root@db01 ~]# mysqldump -uroot -p123 -A >/tmp/all.sql   #注，配置文件已指定套接字

-B    #备份某个库
[root@db01 ~]# mysqldump -uroot -p123 -B wdnmd zhuanghan >/tmp/wdnmd.sql  #备份 wdnmd 和zhuanghan 这两个库

#什么都不加，备份某个表
[root@db01 ~]# mysqldump -uroot -p123 wdnmd t1 t2 >/tmp/wdnmd.sql    #备份 wdnmd 库中的 t1 表和 t2 表。

注：有的库需要先创建，再进行source导入


#特殊备份参数
a. --master-data=2 
	1. 自动记录binlog信息
	2. 自动进行GRL锁(FTWRL),加了 --single-transaction 会有不一样的效果.
	3. 对于全备份+binlog备份，方便找的position的起始号
b. --single-transaction
	1. 对于InnoDB表进行一致性快照备份
	2. 备份期间如果有DDL会备份失败.
	3. 简单理解备份之前拍一张照片，拍完该干嘛干嘛
c. --max_allowed_packet=128M
	1. 应该是最大备份大小
d. -R -E  --triggers 
	1. 备份时，同时将 存储过程\函数\事件\触发器 等高级对象备份走.
	

#标准化备份
所谓标准化，就是将上面的参数都加进来，最后对备份进行压缩
[root@db01 ~]# mysqldump -uroot -B wdnmd --master-data=2 --single-transaction --max_allowed_packet=128M -R -E  --triggers >/tmp/haha.sql
[root@db01 ~]# tar zcf sql.tar.gz /tmp/haha.sql
#一条命令形式
[root@db01 tmp]# mysqldump -uroot -p -A --master-data=2 --single-transaction -R -E --triggers --max_allowed_packet=64M |gzip -9 >/tmp/full_`date +%F`.sql.gz
```

### 案例

**通过mysqldump + binlog 进行数据恢复**

```sh
环境背景： 小型的业务数据库，50G，每天23:00全备，定期binlog异地备份。
故障场景： 周三下午2点，开发Navicat连接数据库实例错误，导致生产数据被误删除（DROP）
恢复思路：
		 1.  挂维护页。
		 2.  检查备份、日志可用。
		 3.  如果只是部分损坏，建议找一个应急库进行恢复
			 a. 全备恢复 
			 b. 日志截取并恢复 
		 4.  恢复后数据校验	（业务测试部门验证）
		 5.  立即备份（停机冷备） 
		 6.  恢复架构系统
		 7.  撤维护页，恢复业务 
模拟故障：
	#随便建立一个库，创建一个表，插入点数据，进行mysqldump备份
	create...
	insert...
	#周三时，往次表插入点数据，并不下心把该库删掉
	insert...
	drop...
故障处理：
	#先恢复全备，就是mysqldump备份
	mysql> source /tmp/full_2300.sql;   #
	#进行binlog恢复今天的操作
	mysql> show master status;   #先查日志文件
	mysql> pager grep -i "drop database 哪个库" -B 10   #显示删库以上的10行
	mysql> show binlog events in 'mysql-bin.000008';   #查看删库上面的position终点号
	[root@db01 ~]# grep "\-- CHANGE MASTER TO" /tmp/full_2300.sql   #position起点
	binlog 恢复   mysqlbinlog  --skip-gtids --start-position=276 mysql-bin.000008 	> /tmp/bin.sql
	mysql> set sql_log_bin=0;
	mysql> source /tmp/bin.sql
	mysql> set sql_log_bin=1;
```



## Percona Xrabackup 应用

### 介绍

```sh
物理备份工具. 备份恢复更快.
支持全备和增量备份
```

### 全备备份 逻辑

```sh
# 8.0之前
预备: 初始化进程和线程,分配专用内存.
备份: 
	 0. 连接目标数据库,获取数据库信息.
	 a. 当前LSN号码记录 ---> show engine InnoDB stutus ; 主要: Last checkpoint at  NO.
	 b. non-InnoDB 数据 :frm , csv , MYI ,MYI      ---->  FTWRL
	 c. unlock tables; 
	 d. Copy  Innodb 数据:  ibd ibdata1  undo tmp ,可以允许DML
	 e. 备份期间的redo截取和备份,并且记录LSN号.
结束:
	记录binlog的当前位置点,将所有备份信息记录至专用日志文件中.

# 8.0之后
预备: 初始化进程和线程,分配专用内存.
备份: 
	 0. 连接目标数据库,获取数据库信息.
	 a. 当前LSN号码记录 ---> show engine InnoDB stutus ; 主要: Last checkpoint at  NO.
	 b. LOCK INSTANCE FOR BACKUP; 	 UNLOCK INSTANCE;
	 c. Copy  Innodb 数据:  ibd ibdata1  undo tmp ,可以允许DML
	 d. 备份期间的redo截取和备份,并且记录LSN号. 
结束:
	记录binlog的当前位置点,将所有备份信息记录至专用日志文件中.
```



### 增量备份 逻辑

```sh
	a. 第一次增量备份,使用全备作为"参照物",把变化的数据页和备份过程中产生的redo保存.
	b. 往后所有的增量,都基于上一次备份作为参照物.把变化的数据页和备份过程中产生的redo保存.
	c. 增量备份只针对InnoDB表有效,所以在8.0之前,针对非InnoDB表,都是全备.
```

### 恢复过程 

```sh
例如:备份策略为,FULL+inc1+inc2....
a. prepare 全备 (CR)
应用redo前滚
应用undo回滚(省略)
b. 合并所有增量到全备并且prepare
应用redo前滚
应用undo回滚(除了最后一次增量,这步省略)
c. 合并后的全备prepare 
d. 恢复备份
```

### PXB的版本兼容性

```sh
MySQL 5.6 ,5.7        : PXB 2.4版本
MySQL 8.0.11 ~ 8.0.19 : PXB 8.0 稳定版.
MySQL 8.0.20          : PXB 8.0.12+ 
```

### 全量备份

```sh
#安装
上传压缩文件，并安装
[root@db01 /opt]# yum install -y percona-xtrabackup-80-8.0.13-1.el7.x86_64

#全量备份
[root@db01 /opt]# mkdir -p /data/backup/
[root@db01 /opt]# xtrabackup --defaults-file=/etc/my.cnf -S /tmp/mysql.sock --user=root --backup --target-dir=/data/backup/full    #开始备份，少了--password=

#数据恢复
先搞破坏：
[root@db01 ~]# pkill mysqld
[root@db01 ~]# rm -rf /data/3306/data/*
[root@db01 ~]# rm -rf /data/3306/logs/*
[root@db01 ~]# rm -rf /data/3306/binlog/*
在进行恢复：
xtrabackup --prepare --target-dir=/data/backup/full   #准备环节（CR）
xtrabackup --copy-back --target-dir=/data/backup/full #拷回数据
[root@db01 /opt]# chown -R mysql. /data/3306/
[root@db01 /opt]# /etc/init.d/mysqld start    #启动
```

### 增量备份

```sh
#安装
上传压缩文件，并安装
[root@db01 /opt]# yum install -y percona-xtrabackup-80-8.0.13-1.el7.x86_64
#增量备份
增量备份，是基于上一次备份LSN变化过的数据页进行备份，在备份同时产生的新变更，会将redo备份。
第一次增量是依赖于全备的。将来的恢复也要合并到全备中，再进行统一恢复。

#1.先创建两个目录，一个第一次全量，以及以后的增量
[root@db01 ~]# mkdir -p /data/backup/full/
[root@db01 ~]# mkdir -p /data/backup/inc/

#2.进行全量备份操作
[root@db01 /opt]# xtrabackup --defaults-file=/etc/my.cnf -S /tmp/mysql.sock --user=root --backup --target-dir=/data/backup/full    #开始备份，少了--password=

#3.模拟增量插入数据
mysql> create database wdnmd;
mysql> use wdnmd;
mysql> create table t1 (id int);
mysql> insert into t1 values(1);
mysql> insert into t1 values(2);

#4.进行增量备份
[root@db01 /opt]# xtrabackup --defaults-file=/etc/my.cnf --user=root -S /tmp/mysql.sock --backup --parallel=4 --target-dir=/data/backup/inc  --incremental-basedir=/data/backup/full   

#5.模拟损坏
[root@db01 ~]# rm -rf /data/3306/data/*
[root@db01 ~]# rm -rf /data/3306/bin-log/*

#6.恢复准备
a.先准备全量备份日志
[root@db01 ~]# xtrabackup --prepare --apply-log-only --target-dir=/data/backup/full
b.后准备增量备份的日志
[root@db01 ~]# xtrabackup --prepare --apply-log-only --target-dir=/data/backup/full  --incremental-dir=/data/backup/inc   #意思就是把他两日志合在一块，都合到full里面
c.准备prepare 过程
[root@db01 ~]# xtrabackup --prepare --target-dir=/data/backup/full
d.数据恢复
[root@db01 ~]# xtrabackup    --copy-back --target-dir=/data/backup/full
e.修改属主和属组
[root@db01 ~]# chown -R mysql. /data/
f.启动数据库
```



## 克隆Clone

### 本地克隆

```sh
#介绍
启动克隆操作的MySQL服务器实例中的数据，克隆到同服务器或同节点上的一个目录里，可以直接启动，只能8.0版本以上

#配置
a.加载插件
mysql> INSTALL PLUGIN clone SONAME 'mysql_clone.so';  #或者写配置文件，如下
[mysqld]
plugin-load-add=mysql_clone.so
clone=FORCE_PLUS_PERMANENT
b.查看开启情况
mysql> SELECT PLUGIN_NAME, PLUGIN_STATUS
FROM INFORMATION_SCHEMA.PLUGINS
WHERE PLUGIN_NAME LIKE 'clone';
c.创建克隆专用用户
mysql> create user clone_user@'%' identified by '123';
mysql> GRANT BACKUP_ADMIN ON *.* TO 'clone_user';   #授权克隆权限
d.创建克隆目录
[root@db01 ~]# mkdir /data/test/
[root@db01 ~]# chown -R  mysql. /data/test/
c.进行克隆操作
[root@db01 ~]# mysql -uclone_user -p123 -h 10.0.0.51
[root@db01 ~]# CLONE LOCAL DATA DIRECTORY = '/data/test/clonedir';
e.观测状态
mysql> SELECT STAGE, STATE, END_TIME FROM performance_schema.clone_progress;
f.启动新的实例
[root@db01 ~]# mysqld_safe  --datadir=/data/test/clonedir --port=3333 --socket=/tmp/mysql3333.sock --user=mysql --mysqlx=OFF &

```

### 远程克隆

```sh
#注意
默认情况下，远程克隆操作会删除接受者(recipient)数据目录中的数据，并将其替换为捐赠者(donor)的克隆数据。您也可以将数据克隆到接受者的其他目录，以避免删除现有数据。(可选)

#配置
a.加载插件(两边都加载)
mysql> INSTALL PLUGIN clone SONAME 'mysql_clone.so';  #或者写配置文件，如下
[mysqld]
plugin-load-add=mysql_clone.so
clone=FORCE_PLUS_PERMANENT
b.查看开启情况
mysql> SELECT PLUGIN_NAME, PLUGIN_STATUS
FROM INFORMATION_SCHEMA.PLUGINS
WHERE PLUGIN_NAME LIKE 'clone';
c.创建克隆专用用户，注意两个用户不能一样
mysql> create user clone_user@'%' identified by '123';
mysql> GRANT all ON *.* TO 'clone_user';   #授权克隆权限
mysql> create user clone_user1@'%' identified by '123';
mysql> GRANT all ON *.* TO 'clone_user1';   #授权克隆权限
d.目标端设置允许白名单
mysql> SET GLOBAL clone_valid_donor_list='10.0.0.51:3306';
e.开始克隆，目标端操作
[root@db01 ~]# mysql -uclone_user1 -p123 -h 10.0.0.52
mysql> CLONE INSTANCE FROM clone@'10.0.0.51':3306 IDENTIFIED BY '123';
```

### 原理

```sh
# PAGE COPY

这里有两个动作
开启redo archiving功能，从当前点开始存储新增的redo log，这样从当前点开始所有的增量修改都不会丢失。同时上一步在page track的page被发送到目标端。确保当前点之前所做的变更一定发送到目标端。
关于redo archiving，实际上这是官方早就存在的功能，主要用于官方的企业级备份工具，但这里clone利用了该特性来维持增量修改产生的redo。 
在开始前会做一次checkpoint， 开启一个后台线程log_archiver_thread()来做日志归档。当有新的写入时(notify_about_advanced_write_lsn)也会通知他去archive。当arch_log_sys处于活跃状态时，他会控制日志写入以避免未归档的日志被覆盖(log_writer_wait_on_archiver), 注意如果log_writer等待时间过长的话， archive任务会被中断掉.

# Redo Copy
停止Redo Archiving", 所有归档的日志被发送到目标端，这些日志包含了从page copy阶段开始到现在的所有日志，另外可能还需要记下当前的复制点，例如最后一个事务提交时的binlog位点或者gtid信息，在系统页中可以找到。'

# Done
目标端重启实例，通过crash recovery将redo log应用上去。

```









## 作业

```sh
1. 场景1:  80G,mysqldump全备+binlog备份,误删除了10M表,进行模拟和恢复
	先进行全备恢复
	再show master
	根据pager 查找 删表操作的position号的终点
	再根据全备备份找到positionde起点
	截取日志，进行source恢复
2. 场景2:  500G数据库,PXB 周日全备+周一-周五binlog,周三时候完全损坏,进行模拟和恢复 
	先模拟，建库、建表、随便插入点数据。进行PXB的全备
	模拟周三场景，随便插入点数据，删除库
	恢复：
	用PXB恢复之前，先show master status ，
	找到 drop database 的操作，找到drop操作之前的 position 号
	去全备路径找到 xtrabackup_binlog_info 查看起点position 号
	用 binlog 截取 这一段日志，重定向到 /tmp/bin.sql
	删除数据库，以及所有的日志。
	XBP 恢复
	恢复完进行 source /tmp/bin.sql
	至此，恢复完成。
3. 扩展题:  500G数据库,PXB 周日全备+周一-周五binlog,周三时候误删除50M的小表,怎么快速恢复? 
	先模拟，建库、建表、随便插入点数据。进行PXB的全备
	模拟周三场景，随便插入点数据，删除表
	恢复：
	用PXB恢复之前，先show master status ，
	找到 drop table 的操作，找到drop操作之前的 position 号
	去全备路径找到 xtrabackup_binlog_info 查看起点position 号
	用 binlog 截取 这一段日志，重定向到 /tmp/bin.sql
	删除数据库，以及所有的日志。
	XBP 恢复
	恢复完进行 source /tmp/bin.sql
	至此，恢复完成。
```

